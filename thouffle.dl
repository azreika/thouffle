.type TokenStream = [first: symbol, rest: TokenStream]

// -- scanner --

/**
 * tokens(program, start, tokens) is true iff:
 *  - @program is an input program,
 *  - @start is a valid index in the program
 *  - @tokens is the stream of tokens starting from @start
 */
.decl tokens(program:symbol, start:number, tokens:TokenStream)

tokens(program, strlen(program), ["EOF", nil]) :- input_program(program). // EOF if we are at the end of the program
tokens(program, start, tokens) :-
    start != strlen(program),
    input_program(program),
    is_valid_index(program, start),
    next_token(program, start, token, end),
    (
        (token = "SPACE", tokens = rest);           // ignore whitespace tokens
        (token != "SPACE", tokens = [token, rest])  // the token read is the start of the current stream
    ),
    tokens(program, end, rest).

/**
 * next_token(program, start, token, end) is true iff:
 *  - @program is an input program
 *  - @start is a valid index in the program
 *  - @token is the next token in the stream
 *  - @end is the index of the program right after the current token is read
 */
.decl next_token(program:symbol, start:number, token:symbol, end:number)
next_token(program, start, token, end) :-
    input_program(program),
    is_valid_index(program, start),
    (
        (start = strlen(program), token = "EOF", end = start + 1);      // handle EOF
        (start != strlen(program), is_valid_index(program, end),        // otherwise, end is a valid index
            (
                // handle print
                ("print" = substr(program, start, 5), token = "PRINT", end = start + 5);

                // handle numbers
                (next_char = substr(program, start, 1), is_digit(next_char), next_number(program, _, start, end), token = "NUMBER");

                // handle single-character tokens
                ("print" != substr(program, start, 5), next_char = substr(program, start, 1), end = start + 1,
                    (
                        (next_char = "+", token = "PLUS", end = start + 1);
                        (next_char = "-", token = "MINUS", end = start + 1);
                        (next_char = "/", token = "SLASH", end = start + 1);
                        (next_char = "*", token = "STAR", end = start + 1);
                        (next_char = "(", token = "LPAREN", end = start + 1);
                        (next_char = ")", token = "RPAREN", end = start + 1);
                        (is_whitespace(next_char), token = "SPACE", end = start + 1);

                        // error - nothing matches
                        (next_char != "+", next_char != "-", next_char != "/", next_char != "*", next_char != "(", next_char != ")", !is_whitespace(next_char), !is_digit(next_char), token = "ERROR", end = start + 1)
                    )
                )
            )
        )
    ).

/**
 * next_number(program, start, end) is true iff:
 *  - @program is an input program
 *  - @start is a valid index in the program
 *  - @end is the index just after the current number is read
 */
.decl next_number(program:symbol, literal:symbol, start:number, end:number)
next_number(program, literal, start, end) :-
    input_program(program),
    is_valid_index(program, start),
    (
        // reached the end of the program
        (start = strlen(program), end = start, literal = "");

        // still within the program
        (start != strlen(program), next_char = substr(program, start, 1),
            (
                // still in the number!
                (is_digit(next_char), next_number(program, next_num, start+1, end), literal = cat(next_char, next_num));

                // number has finished
                (!is_digit(next_char), start = end, literal="")
            )
        )
    ).

// -- parser --
.decl parser(program:symbol, cpp:symbol)
parser(program, cpp) :-
    input_program(program),
    tokens(program, 0, ts),
    parse_program(ts, _, cpp).

.decl parse_program(ts:TokenStream, rest:TokenStream, cpp:symbol)
parse_program(ts, rest, cpp) :-
    parse_expression(ts, rest, cpp).

.decl parse_expression(ts:TokenStream, rest:TokenStream, cpp:symbol)
parse_expression(ts, rest, cpp) :-
    tokens(_, _, rest),
    tokens(_, _, ts),
    (
        (ts = ["LPAREN", ["PRINT", tail]], parse_expression(tail, ["RPAREN", rest], cpp_rest), cpp = cat("std::cout << ", cat(cpp_rest, " << std::endl;")));
        (ts = ["NUMBER", rest], cpp = "(X)");
        (ts = nil, rest = nil, cpp = "");
        (ts = ["LPAREN", [op, tail]], parse_expression(tail, first, cpp_first), parse_expression(first, rest, cpp_second), cpp = cat("(", cat(cpp_first, cat(nop, cpp_second)), ")" ),
        (
            (op = "PLUS", nop = "+");
            (op = "MINUS", nop = "-");
            (op = "STAR", nop = "*");
            (op = "SLASH", nop = "/")
        ))
    ).

// -- helpers --

/**
 * is_valid_index(program, idx) is true iff:
 *  - @program is an input program
 *  - @idx is between 0 and strlen(program), inclusive
 */
.decl is_valid_index(program:symbol, idx:number)
is_valid_index(program, 0) :- input_program(program).
is_valid_index(program, x+1) :- is_valid_index(program, x), x < strlen(program).

/**
 * is_whitespace(x) is true iff x is a whitespace character
 */
.decl is_whitespace(x:symbol)
is_whitespace(" ").

/**
 * is_whitespace(x) is true iff x is a digit
 */
.decl is_digit(x:symbol)
is_digit("0"). is_digit("1").
is_digit("2"). is_digit("3").
is_digit("4"). is_digit("5").
is_digit("6"). is_digit("7").
is_digit("8"). is_digit("9").

/**
 * ts_to_string(tokens, rep) is true iff:
 *  - @tokens is a stream of tokens
 *  - @rep is the string representation of tokens
 */
.decl ts_to_string(tokens:TokenStream, rep:symbol)
ts_to_string(nil, "").
ts_to_string([token, rest], cat(token, cat(".", rest_rep))) :-
    tokens(_, _, [token,rest]),
    ts_to_string(rest, rest_rep).

// -- input --
.decl input_program(program:symbol)
.input input_program()

// -- output --
.decl tokenizer(program:symbol, stream:symbol)
tokenizer(program, stream) :- input_program(program), tokens(program, 0, ts), ts_to_string(ts, stream).
.output input_program()
.output tokenizer()
.output parser()
